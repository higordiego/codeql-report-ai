---
alwaysApply: false
---
# Regra: Library Specialist — Integração HTTP com ChatGPT para Análise de Código Python (code-only)

**Objetivo:**
Implementar um fluxo automatizado que leia **apenas arquivos de código Python** de um diretório, **exclua dependências/artefatos**, **faça chunking seguro**, e **integre por HTTP** com o ChatGPT para produzir um **relatório de análise técnica** e **recomendações de melhoria**.

## Parâmetros (preencha antes de rodar)

* `OPENAI_API_KEY`: `{{OPENAI_API_KEY}}`
* `BASE_URL`: `{{https://api.openai.com/v1/chat/completions}}` (ou endpoint compatível)
* `MODEL`: `{{gpt-4.1-mini}}` (ou o modelo de sua preferência)
* `TEMPERATURE`: `{{0.2}}`
* `PROJECT_ROOT`: `{{./caminho/do/projeto}}`
* `MAX_FILE_BYTES`: `{{350000}}`  # \~350 KB por arquivo (ajuste conforme necessário)
* `MAX_PAYLOAD_TOKENS`: `{{120000}}` # limite total de contexto
* `CHUNK_TARGET_TOKENS`: `{{3000}}`  # alvo por chunk
* `RATE_LIMIT_RPS`: `{{2}}`         # requisições por segundo (throttle)

## Escopo — Considere SOMENTE código

**Incluir (somente se forem código):**

* `**/*.py`
* (Opcional para contexto mínimo de build) `pyproject.toml`, `poetry.lock`, `requirements.txt`, `setup.cfg`, `setup.py`

**Excluir SEMPRE (dependências/artefatos/logs):**

* `.git/**`, `.hg/**`, `.svn/**`
* `**/__pycache__/**`, `**/.mypy_cache/**`, `**/.pytest_cache/**`, `**/.ruff_cache/**`, `**/.tox/**`
* `**/.venv/**`, `**/venv/**`, `**/env/**`
* `**/dist/**`, `**/build/**`, `**/*.egg-info/**`
* `**/*.log`, `**/*.tmp`, `**/*.lock`
* `node_modules/**` (caso exista)
* Qualquer arquivo > `MAX_FILE_BYTES` (aplicar truncamento esperto: head+tail)

> Regra dura: **não** enviar dependências, binários ou arquivos grandes inteiros; apenas **código-fonte Python relevante**.

## Saídas esperadas

1. `ANALYSE.md` — relatório técnico (arquitetura, riscos, segurança, qualidade, performance).
2. `FINDINGS.json` — lista estruturada de achados (arquivo, linha, severidade, descrição, recomendação).
3. `PATCH_SUGGESTIONS.md` — sugestões de refatoração/patch com snippets.
4. (Opcional) `CALLGRAPH.txt` — visão geral de dependências entre módulos/entrypoints.

## Passo a passo (o que o agente deve fazer)

1. **Descoberta de arquivos**

   * Caminhar recursivamente por `PROJECT_ROOT`.
   * Filtrar via listas de inclusão/ exclusão acima.
   * Aplicar **deduplicação por path** e **ordenar** por relevância: entrypoints (`main.py`, `__init__.py`), camadas core (`domain/`, `app/`, `src/`), segurança (`auth/`, `crypto/`, `secrets/`), interfaces (`api/`, `routers/`), utilitários.

2. **Pré-processamento**

   * Para cada arquivo:

     * Se `size <= MAX_FILE_BYTES`, ler completo.
     * Se `size > MAX_FILE_BYTES`, criar **três janelas**: `head( ~1/3 ) + middle markers + tail( ~1/3 )`, preservando **linhas e contexto de funções/classes** (não cortar no meio de blocos, preferir limites entre `def/class`).
   * Normalizar quebras de linha para `\n`. Remover trailing spaces.

3. **Chunking**

   * Agrupar arquivos em **chunks** visando \~`CHUNK_TARGET_TOKENS`.
   * Garantir que arquivos intimamente relacionados fiquem no mesmo chunk (por pasta/namespace).
   * Cada chunk recebe **header** com lista de arquivos e hashes (`sha256` por arquivo) para rastreabilidade.

4. **Prompting (mensagens)**

   * **system** (invariável):

     > Você é um *Library Specialist* focado em análise estática e revisão de bibliotecas Python. Seu papel é identificar riscos de segurança, problemas de design, dívidas técnicas, antipadrões e oportunidades de melhoria. Seja **objetivo, técnico e acionável**. Forneça referências a trechos por `arquivo:linha` quando possível. Proponha refatorações seguras.
   * **developer** (regras do usuário):

     > Analise **apenas o código Python fornecido**, ignorando dependências e artefatos. Priorize: segurança (injeção, deserialização, subprocess, path traversal, secrets), qualidade (complexidade, acoplamento), performance (I/O, concorrência), e observabilidade. Aponte **causa raiz** e **patch sugerido**. Mantenha severidades: `critical|high|medium|low|info`.
   * **user** (contexto do chunk):

     * Descrever brevemente a estrutura do chunk (arquivos, hashes, paths).
     * Incluir conteúdo bruto dos arquivos do chunk (ou janelas head/tail se truncado).
     * **Pedido explícito de saída**:

       1. lista de achados (`json compact`) +
       2. resumo técnico por tópico +
       3. snippets de correção.

5. **Integração HTTP (obrigatória)**

   * Enviar cada chunk em **requisições independentes** para `BASE_URL` (Chat Completions compatível).
   * **Headers**:

     * `Authorization: Bearer ${OPENAI_API_KEY}`
     * `Content-Type: application/json`
   * **Body** (exemplo genérico):

     ```json
     {
       "model": "{{MODEL}}",
       "temperature": {{TEMPERATURE}},
       "messages": [
         {"role": "system", "content": "...(system acima)..."},
         {"role": "developer", "content": "...(developer acima)..."},
         {"role": "user", "content": "CHUNK HEADER + CÓDIGO(S) AQUI"}
       ]
     }
     ```
   * **Throttle**: respeitar `RATE_LIMIT_RPS`. Repetir com backoff exponencial em `429/5xx`.
   * **Privacidade**: **não** enviar segredos reais. Se detectados, mascarar (`****`).

6. **Agregação de respostas**

   * Mesclar todos os `json` de achados por `arquivo+linha+descrição` (dedupe fuzzy).
   * Ordenar por severidade e impacto.
   * Gerar:

     * `FINDINGS.json` (estrutura final).
     * `ANALYSE.md` com:

       * Visão geral do projeto
       * Tabela de severidades
       * Top 10 riscos (com links `arquivo:linha`)
       * Recomendações priorizadas (quick wins → estratégicas)
       * Checklists (segurança, qualidade, performance, observabilidade)
     * `PATCH_SUGGESTIONS.md` com diffs/sugestões.

7. **Critérios de aceite**

   * Nada de dependências/artefatos nos prompts.
   * Requisições **apenas HTTP** (sem SDKs).
   * Saídas reproduzíveis, com paths e linhas corretos.
   * Respeitar limites de tokens e rate limit.
   * Relatório final **executivo + técnico** e **ações claras**.

## Modelo de Prompt (user) por chunk — cole como template

```
[CHUNK HEADER]
project_root: {{PROJECT_ROOT}}
arquivos: 
- {{relative_path_1}} (sha256: {{hash1}}, linhas: {{N1}})
- {{relative_path_2}} (sha256: {{hash2}}, linhas: {{N2}})
...

[OBJETIVOS]
1) Encontrar vulnerabilidades (injeção, subprocess, path traversal, secrets hardcoded, SSRF, RCE, deserialização insegura).
2) Identificar problemas de design (acoplamento, circular deps, violação SRP, exceções genéricas).
3) Oportunidades de performance (I/O bloqueante, estruturas ineficientes, concorrência).
4) Observabilidade (logs pobres, métricas, rastreabilidade).

[SAÍDA OBRIGATÓRIA]
1) findings_json (único bloco JSON compacto)
2) resumo_técnico (markdown)
3) patches_sugeridos (snippets/diffs)

[CONTEÚDO]
>>> BEGIN FILE {{relative_path_1}}
{{codigo_1}}
>>> END FILE

>>> BEGIN FILE {{relative_path_2}}
{{codigo_2}}
>>> END FILE

... (repetir para todos do chunk)
```

## Exemplo de chamada HTTP (cURL)

```bash
curl -sS -X POST "{{BASE_URL}}" \
  -H "Authorization: Bearer ${OPENAI_API_KEY}" \
  -H "Content-Type: application/json" \
  -d @- <<'JSON'
{
  "model": "{{MODEL}}",
  "temperature": {{TEMPERATURE}},
  "messages": [
    {"role":"system","content":"(system aqui)"},
    {"role":"developer","content":"(developer aqui)"},
    {"role":"user","content":"(user chunk aqui)"}
  ]
}
JSON
```

## Políticas & Segurança

* **Nunca** enviar `.env`, chaves, tokens; se encontrados, **mascarar e reportar** no `FINDINGS.json`.
* Sanitizar conteúdo potencialmente sensível.
* Não executar código; análise **estática** apenas.
* Logs sem dados sensíveis.

## Estratégia de Truncamento Seguro (quando necessário)

* Preferir **head \~60% + tail \~40%**, cortando em limites de `def/class`.
* Incluir sumário de trechos omitidos (`… N linhas omitidas …`) por arquivo.
* Manter números de linha relativos ao arquivo original (com mapeamento linha-base).

## Formato de `FINDINGS.json` (exemplo)

```json
[
  {
    "file": "app/services/runner.py",
    "line": 87,
    "severity": "high",
    "category": "command_injection",
    "title": "Uso perigoso de subprocess com entrada não confiável",
    "description": "Comando construído a partir de input do usuário sem validação.",
    "recommendation": "Usar lista de argumentos, shlex.quote, mapa de comandos permitidos.",
    "reference": "CWE-78"
  }
]
```

---

### Meu desejo (intenção do usuário, para guiar o agente)

* “Quero **resultados melhores** de análise de código Python com foco em **segurança**, **qualidade** e **performance**, usando **somente o código** do repositório (sem dependências).
* A integração com o ChatGPT deve ocorrer **exclusivamente via HTTP**, respeitando limites e privacidade.
* Desejo **saídas acionáveis**: lista priorizada de achados (`FINDINGS.json`), relatório técnico (`ANALYSE.md`) e **patches sugeridos** (`PATCH_SUGGESTIONS.md`).
* O agente deve ser **objetivo, técnico, rastreável** (arquivo\:linha) e priorizar **causa raiz + correção**.”

---

Se quiser, adapto esse prompt para gerar também um **sumário executivo** em até 10 bullets para stakeholders não técnicos.
