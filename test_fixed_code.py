# Corrected Code - Security Vulnerabilities Resolved
# Automatically generated by Code Report
# This code implements security best practices

import subprocess
import shlex
import logging
import os
import re

# Logging configuration for audit
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# List of allowed commands for secure execution
ALLOWED_COMMANDS = ['ls', 'pwd', 'whoami', 'date', 'echo', 'cat', 'grep']

def validate_input(user_input: str) -> bool:
    """Validate user input for security"""
    if not user_input or not user_input.strip():
        return False
    # Check for dangerous patterns
    dangerous_patterns = [
        r'[;&|`$]',  # Command separators
        r'\.\./',   # Path traversal
        r'rm\s+-rf', # Dangerous rm command
    ]
    for pattern in dangerous_patterns:
        if re.search(pattern, user_input):
            return False
    return True

def safe_command_execution(user_input: str) -> str:
    """Execute commands securely"""
    try:
        # Input validation
        if not validate_input(user_input):
            logger.warning(f"Invalid input detected: {user_input}")
            return "Error: Invalid input"
        
        # Split command into parts
        command_parts = shlex.split(user_input)
        
        # Check if command is in allowed list
        if command_parts[0] not in ALLOWED_COMMANDS:
            logger.warning(f"Command not allowed: {command_parts[0]}")
            return f"Error: Command '{command_parts[0]}' not allowed"
        
        # Execute command securely
        result = subprocess.run(
            command_parts,
            shell=False,  # Never use shell=True
            capture_output=True,
            text=True,
            timeout=30  # Timeout for security
        )
        
        logger.info(f"Command executed: {command_parts[0]}")
        return result.stdout if result.returncode == 0 else f"Error: {result.stderr}"
            
    except subprocess.TimeoutExpired:
        logger.error("Command execution timed out")
        return "Error: Command execution timed out"
    except Exception as e:
        logger.error(f"Command execution error: {str(e)}")
        return f"Error: {str(e)}"

def main():
    """Main function with secure command execution"""
    print("Secure Command Execution Tool")
    print("Available commands:", ", ".join(ALLOWED_COMMANDS))
    
    while True:
        try:
            user_input = input("Enter command (or 'quit' to exit): ")
            
            if user_input.lower() == 'quit':
                break
            
            result = safe_command_execution(user_input)
            print(f"Result: {result}")
            
        except KeyboardInterrupt:
            print("\nExiting...")
            break
        except Exception as e:
            print(f"Error: {str(e)}")

if __name__ == "__main__":
    main()
